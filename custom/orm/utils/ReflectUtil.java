package custom.orm.utils;

import java.lang.reflect.*;
import java.util.ArrayList;
import java.util.List;

import custom.orm.db.utils.annotations.*;

public class ReflectUtil {
    private Class<?> entityClass;

    public ReflectUtil(Class<?> entityClass) {
        this.entityClass = entityClass;
    }

    public Class<?> getEntityClass() {
        return entityClass;
    }

    public void setEntityClass(Class<?> entityClass) {
        this.entityClass = entityClass;
    }

    public String getTableName() throws Exception {
        if (!this.getEntityClass().isAnnotationPresent(Entity.class)) {
            throw new IllegalArgumentException("Reflect util entity class must be annotated @Entity");
        }

        Entity entityAnnotation = this.getEntityClass().getAnnotation(Entity.class);
        String tableName = entityAnnotation.tableName();
        if (tableName.isBlank()) {
            // means no tableName was set, so we use the class's name, to lowercase
            tableName = this.getEntityClass().getSimpleName().toLowerCase();
        }

        return tableName.trim();
    }

    public Field[] getColumns(boolean excludeAuto) {
        List<Field> fieldList = new ArrayList<>();

        Field[] allDeclared = this.getEntityClass().getDeclaredFields();
        for (Field field : allDeclared) {
            if ((excludeAuto && !field.isAnnotationPresent(AutoGenerated.class)) || !excludeAuto) {
                if (!field.isAnnotationPresent(NotMapped.class)) {

                    fieldList.add(field);
                }
            }
        }

        Object[] tempArr = fieldList.toArray();

        Field[] results = new Field[tempArr.length];
        for (int i = 0; i < tempArr.length; i++) {
            results[i] = (Field) tempArr[i];
        }

        return results;
    }

    private String getColumnName(Field f) {
        if (f.isAnnotationPresent(Column.class)) {
            Column c = f.getAnnotation(Column.class);
            return c.name();
        } else {
            return f.getName().toLowerCase();
        }
    }

    public String[] getColumnNames(Field[] fields) {
        if (fields == null) {
            fields = this.getColumns(true);
        }

        String[] results = new String[fields.length];
        for (int i = 0; i < results.length; i++) {
            results[i] = getColumnName(fields[i]);
        }

        return results;
    }

    public String getColumnLineup(String[] columnNames) {
        if (columnNames == null) {
            columnNames = getColumnNames(null);
        }
        return String.join(", ", columnNames);
    }

    private String columnsEqualString(String[] columnNames) {
        if (columnNames == null) {
            columnNames = getColumnNames(null);
        }

        for (int i = 0; i < columnNames.length; i++) {
            columnNames[i] += " = ?";
        }
        return String.join(", ", columnNames);
    }

    public String formInsertQuery(Field[] fields) throws Exception {
        String sql = "INSERT INTO " + getTableName() + " (";

        if (fields == null) {
            fields = this.getColumns(true);
        }

        String[] colNames = getColumnNames(fields);
        String lineup = getColumnLineup(colNames);
        String questionMarks = String.join(", ", "?".repeat(colNames.length).split(""));

        sql += lineup + ") VALUES (" + questionMarks + ")";

        return sql;
    }

    public static String getAccessMethodName(Field f, String method) {
        String name = f.getName();
        String capitalizedName = name.substring(0, 1).toUpperCase() + name.substring(1);

        return method.toLowerCase() + capitalizedName;
    }

    public Field getIdCol() {
        Field[] allFields = this.getEntityClass().getDeclaredFields();
        for (Field field : allFields) {
            if (field.isAnnotationPresent(Id.class)) {
                return field;
            }
        }
        return null;
    }

    public String getIdColName(Field idField) {
        if (idField == null) {
            idField = getIdCol();
        }

        return getColumnName(idField);
    }

    public String formSelectQuery(Field[] fields) throws Exception {
        String sql = "SELECT ";

        if (fields == null) {
            fields = getColumns(false);
        }

        String lineup = getColumnLineup(getColumnNames(fields));

        sql += lineup + " FROM " + getTableName() + " WHERE 1=1";

        return sql;
    }

    public String appendConditions(String baseSql, String... conditions) throws Exception {
        if (baseSql == null) {
            baseSql = formSelectQuery(null);
        }

        if (conditions != null && conditions.length > 0) {
            for (String condition : conditions) {
                baseSql += " AND " + condition;
            }
        }

        return baseSql;
    }

    public String formSelectQuery(Field[] fields, String[] conditions, String[] afterWhere) throws Exception {
        String baseSql = this.formSelectQuery(fields);
        if (conditions != null) {
            baseSql = this.appendConditions(baseSql, conditions);
        }

        if (afterWhere != null && afterWhere.length > 0) {
            for (String other : afterWhere) {
                baseSql += " " + other;
            }
        }

        return baseSql;
    }

    public String formUpdateQuery() throws Exception {
        String table = getTableName();

        Field[] allFields = getColumns(false);
        String[] colNames = getColumnNames(allFields);
        String colsLineup = columnsEqualString(colNames);

        try {
            String idCol = getIdColName(null);

            String sql = "UPDATE " + table + " SET " + colsLineup + " WHERE " + idCol + " = ?";
            return sql;
        } catch (NullPointerException e) {
            throw new Exception("Entity must have an annotated id field to perform update");
        }

    }

    public Object getIdValue(Object objToPopulate) throws Exception {
        ReflectUtil reflectUtil = new ReflectUtil(objToPopulate.getClass());

        Field idField = reflectUtil.getIdCol();
        if(idField == null) {
            throw new IllegalArgumentException("Object in parameters must have a field annotated as Id");
        }

        try {
            String idGetterName = ReflectUtil.getAccessMethodName(idField, AccessMethods.GET.getValue());
            Method idGetter = objToPopulate.getClass().getDeclaredMethod(idGetterName, null);
    
            Object idValue = idGetter.invoke(objToPopulate, null);
            return idValue;
        } catch (NoSuchMethodException e) {
            throw new Exception("Public getter method must be declared for the id field", e);
        }
    }

}
